events {}
http {
  # 로그(JSON 형태 권장. 예시는 단순화)
  log_format main '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent '
                  '"$http_user_agent" rt=$request_time rid=$upstream_http_x_request_id';
  access_log /var/log/nginx/access.log main;

  # 레이트리밋: IP 기준(초기), 필요시 X-Actor 단위로 확장
  limit_req_zone $binary_remote_addr zone=reqs:10m rate=30r/m;

  # 캐시
  proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=apicache:100m max_size=1g inactive=6h use_temp_path=off;

  upstream corp_api {
    server corp-api:8080;  # 회사 API 서버(내부)
  }

  server {
    listen 443 ssl;
    server_name gw.example.com;

    # 서버 TLS
    ssl_certificate /etc/nginx/tls/server.crt;
    ssl_certificate_key /etc/nginx/tls/server.key;

    # mTLS(클라이언트 인증)
    ssl_client_certificate /etc/nginx/tls/ca.crt;
    ssl_verify_client on;

    # 공통 헤더 전달
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;

    location /mcp/dispatch {
      limit_req zone=reqs burst=10 nodelay;

      # 캐시: 멱등 조회성 응답만(회사 API 서버에서 Cache-Control 헤더로 제어 권장)
      proxy_cache apicache;
      proxy_cache_valid 200 10m;
      proxy_ignore_headers Set-Cookie;

      # 서킷브레이커 유사(단순화): 백엔드 실패시 빠른 우회/실패
      proxy_next_upstream error timeout http_502 http_503 http_504;
      proxy_next_upstream_tries 1;
      proxy_read_timeout 60s;

      proxy_pass http://corp_api/dispatch;
    }
  }
} 